{
  "language": "Solidity",
  "sources": {
    "contracts/Exchanger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./library/SafeDecimalMath.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISynthesizer.sol\";\nimport \"./interfaces/IFeePool.sol\";\n\ncontract Exchanger is Initializable, AddressResolverUpgradeable {\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    bool public exchangeEnabled;\n\n    bytes32 private constant xUSD = \"ShaUSD\";\n\n    bytes32 private constant DOWS = \"DOWS\";\n\n    function initialize(address _resolver) external initializer {\n        __Ownable_init();\n        __AddressResolver_init(_resolver);\n        exchangeEnabled = true;\n    }\n\n    function exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress\n    ) external onlySynthesizerOrSynth returns (uint256 amountReceived) {\n        require(\n            sourceCurrencyKey != destinationCurrencyKey,\n            \"Can't be same synth\"\n        );\n        require(sourceAmount > 0, \"Zero amount\");\n        require(exchangeEnabled, \"Exchanging is disabled\");\n\n        ISynthesizer _synthesizer = synthesizer();\n        IOracle _oracle = oracle();\n\n        _synthesizer.synths(sourceCurrencyKey).burn(from, sourceAmount);\n\n        uint256 destinationAmount = _oracle.effectiveValue(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n\n        uint256 fee;\n\n        (amountReceived, fee) = calculateExchangeAmountMinusFees(\n            destinationAmount\n        );\n\n        // // Issue their new synths\n        _synthesizer.synths(destinationCurrencyKey).issue(\n            destinationAddress,\n            amountReceived\n        );\n\n        // Remit the fee if required\n        if (fee > 0) {\n            remitFee(_oracle, _synthesizer, fee, destinationCurrencyKey);\n        }\n\n        emit SynthExchanged(\n            from,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            amountReceived,\n            destinationAddress\n        );\n    }\n\n    function remitFee(\n        IOracle _oracle,\n        ISynthesizer _synthesizer,\n        uint256 fee,\n        bytes32 currencyKey\n    ) internal {\n        // Remit the fee in xUSDs\n        uint256 usdFeeAmount = _oracle.effectiveValue(currencyKey, fee, xUSD);\n        _synthesizer.synths(xUSD).issue(feePool().FEE_ADDRESS(), usdFeeAmount);\n        // Tell the fee pool about this.\n        feePool().recordFeePaid(usdFeeAmount);\n\n        // Remit the rewards in DOWS\n        uint256 rewardAmount = _oracle.effectiveValue(currencyKey, fee, DOWS);\n        feePool().recordRewardPaid(rewardAmount);\n\n        emit FeePaided(currencyKey, usdFeeAmount, rewardAmount);\n    }\n\n    function calculateExchangeAmountMinusFees(uint256 destinationAmount)\n        internal\n        view\n        returns (uint256 amountReceived, uint256 fee)\n    {\n        // Get the exchange fee rate\n        uint256 exchangeFeeRate = feePool().exchangeFeeRate();\n\n        amountReceived = destinationAmount.multiplyDecimal(\n            SafeDecimalMath.unit().sub(exchangeFeeRate)\n        );\n\n        fee = destinationAmount.sub(amountReceived);\n    }\n\n    function setExchangeEnabled(bool _exchangeEnabled) external onlyOwner {\n        exchangeEnabled = _exchangeEnabled;\n    }\n\n    function oracle() internal view returns (IOracle) {\n        return\n            IOracle(\n                resolver.requireAndGetAddress(\n                    \"Oracle\",\n                    \"Missing Oracle address\"\n                )\n            );\n    }\n\n    function synthesizer() internal view returns (ISynthesizer) {\n        return\n            ISynthesizer(\n                resolver.requireAndGetAddress(\n                    \"Synthesizer\",\n                    \"Missing Synthesizer address\"\n                )\n            );\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return\n            IFeePool(\n                resolver.requireAndGetAddress(\n                    \"FeePool\",\n                    \"Missing FeePool address\"\n                )\n            );\n    }\n\n    modifier onlySynthesizerOrSynth() {\n        ISynthesizer _synthesizer = synthesizer();\n        require(\n            msg.sender == address(_synthesizer) ||\n                _synthesizer.synthsByAddress(msg.sender) != bytes32(0),\n            \"Exchanger: Only Synthesizer or a synth contract can perform this action\"\n        );\n        _;\n    }\n\n    event SynthExchanged(\n        address indexed account,\n        bytes32 fromCurrencyKey,\n        uint256 fromAmount,\n        bytes32 toCurrencyKey,\n        uint256 toAmount,\n        address toAddress\n    );\n\n    event FeePaided(\n        bytes32 currencyKey,\n        uint256 usdFeeAmount,\n        uint256 rewardAmount\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/library/SafeDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\n * @dev Functions accepting uints in this contract and derived contracts\n * are taken to be such fixed point decimals of a specified precision (either standard\n * or high).\n */\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /** \n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /** \n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     * \n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     * \n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n"
    },
    "contracts/library/AddressResolverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./AddressResolver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract AddressResolverUpgradeable is Initializable, OwnableUpgradeable {\n    AddressResolver public resolver;\n\n    function __AddressResolver_init(address _resolver) internal initializer {\n        __Ownable_init();\n        __AddressResolver_init_unchained(_resolver);\n    }\n\n    function __AddressResolver_init_unchained(address _resolver)\n        internal\n        initializer\n    {\n        resolver = AddressResolver(_resolver);\n    }\n\n    function setResolver(AddressResolver _resolver) public onlyOwner {\n        resolver = _resolver;\n        emit ResolverUpdated(_resolver);\n    }\n\n    event ResolverUpdated(AddressResolver _resolver);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @title ExchangeRates interface\n */\ninterface IOracle {\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function anyRateIsStale(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function ratesAndStaleForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] calldata, bool);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n}\n"
    },
    "contracts/interfaces/ISynthesizer.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../Synth.sol\";\n\nabstract contract ISynthesizer {\n    uint256 public totalSupply;\n\n    uint256 public issuanceRatio;\n\n    mapping(bytes32 => Synth) public synths;\n\n    mapping(address => bytes32) public synthsByAddress;\n\n    uint256[] public debtLedger;\n\n    function balanceOf(address account) external view virtual returns (uint256);\n\n    function transfer(address to, uint256 value)\n        external\n        virtual\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external virtual returns (bool);\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external virtual returns (uint256 amountReceived);\n\n    function issueSynths(uint256 amount) external virtual;\n\n    function issueMaxSynths() external virtual;\n\n    function burnSynths(uint256 amount) external virtual;\n\n    function settle(bytes32 currencyKey)\n        external\n        virtual\n        returns (uint256 reclaimed, uint256 refunded);\n\n    function collateralisationRatio(address issuer)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function totalIssuedSynths(bytes32 currencyKey)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        virtual\n        returns (uint256, uint256);\n\n    function isWaitingPeriod(bytes32 currencyKey)\n        external\n        view\n        virtual\n        returns (bool);\n\n    function debtLedgerLength() external view virtual returns (uint256);\n\n    function transferableShadows(address account)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint256 susdAmount,\n        address liquidator\n    )\n        external\n        virtual\n        returns (uint256 totalRedeemed, uint256 amountToLiquidate);\n}\n"
    },
    "contracts/interfaces/IFeePool.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\n\n/**\n * @title FeePool Interface\n */\nabstract contract IFeePool {\n\n    address public FEE_ADDRESS;\n    uint public exchangeFeeRate;\n\n    function amountReceivedFromExchange(uint value) virtual external view returns (uint);\n\n    function amountReceivedFromTransfer(uint value) virtual external view returns (uint);\n\n    function recordFeePaid(uint xUSDAmount) virtual external;\n\n    function recordRewardPaid(uint xUSDAmount) virtual external;\n\n    function appendAccountIssuanceRecord(address account, uint lockedAmount, uint debtEntryIndex) virtual external;\n\n    function setRewardsToDistribute(uint amount) virtual external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/library/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n\ncontract AddressResolver is Ownable {\n    mapping(bytes32 => address) public repository;\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) public onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n        for (uint i = 0; i < names.length; i++) {\n            require(Address.isContract(destinations[i]), \"Must be contract address\");\n            repository[names[i]] = destinations[i];\n        }\n    }\n\n    function getAddress(bytes32 name) public view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) public view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Synth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./interfaces/IFeePool.sol\";\nimport \"./interfaces/ISynthesizer.sol\";\nimport \"./interfaces/IExchanger.sol\";\n\ncontract Synth is Initializable, OwnableUpgradeable, ERC20Upgradeable, AddressResolverUpgradeable {\n\n    bytes32 public currencyKey;\n\n    bytes32 private constant xUSD = \"ShaUSD\";\n    function initialize(\n        string calldata _tokenName,\n        string calldata _tokenSymbol,\n        bytes32 _currencyKey,\n        address _resolver\n    ) external initializer {\n        __Ownable_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __AddressResolver_init(_resolver);\n        currencyKey = _currencyKey;\n    }\n\n    function transferableSynths(address account) public view returns (uint) {\n        return balanceOf(account);\n    }\n\n    function issue(address account, uint amount) external onlyInternalContracts {\n        _mint(account, amount);\n        emit Issued(account, amount);\n    }\n\n    function burn(address account, uint amount) external onlyInternalContracts {\n        _burn(account, amount);\n        emit Burned(account, amount);\n    }\n\n    function purge(address[] calldata addresses) external onlyOwner {\n        for (uint i = 0; i < addresses.length; i++) {\n            address holder = addresses[i];\n\n            uint amountHeld = balanceOf(holder);\n\n            if (amountHeld > 0) {\n                exchanger().exchange(holder, currencyKey, amountHeld, xUSD, holder);\n                emit Purged(holder, amountHeld);\n            }\n        }\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        if (recipient == feePool().FEE_ADDRESS()) {\n            return _transferToFeeAddress(recipient, amount);\n        }\n\n        if (recipient == address(0)) {\n            return _burn(_msgSender(), amount);\n        }\n        return super._transfer(sender,recipient,amount);\n    }\n\n    /**\n     * non-xUSD synths are exchanged into xUSD via synthInitiatedExchange\n     * notify feePool to record amount as fee paid to feePool \n    */\n    function _transferToFeeAddress(address recipient, uint amount) internal{\n        uint amountInUSD;\n\n        if (currencyKey == xUSD) {\n            amountInUSD = amount;\n            super._transfer(_msgSender(), recipient, amount);\n        } else {\n            amountInUSD = exchanger().exchange(_msgSender(), currencyKey, amount, xUSD, feePool().FEE_ADDRESS());\n        }\n\n        feePool().recordFeePaid(amountInUSD);\n\n        return;\n    }\n\n    function synthesizer() internal view returns (ISynthesizer) {\n        return ISynthesizer(resolver.requireAndGetAddress(\"Synthesizer\", \"Missing Synthesizer address\"));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(resolver.requireAndGetAddress(\"FeePool\", \"Missing FeePool address\"));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(resolver.requireAndGetAddress(\"Exchanger\", \"Missing Exchanger address\"));\n    }\n\n    modifier onlyInternalContracts() {\n        bool isSynthesizer = msg.sender == address(synthesizer());\n        bool isFeePool = msg.sender == address(feePool());\n        bool isExchanger = msg.sender == address(exchanger());\n\n        require(\n            isSynthesizer || isFeePool || isExchanger,\n            \"Only Synthesizer, FeePool, Exchanger or Issuer contracts allowed\"\n        );\n        _;\n    }\n\n    event Issued(address indexed account, uint value);\n\n    event Burned(address indexed account, uint value);\n\n    event Purged(address indexed account, uint value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/interfaces/IExchanger.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\n\ninterface IExchanger {\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (uint reclaimAmount, uint rebateAmount);\n\n    function settle(address from, bytes32 currencyKey) external returns (uint reclaimed, uint refunded);\n\n    function exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress\n    ) external returns (uint amountReceived);\n\n    function calculateAmountAfterSettlement(address from, bytes32 currencyKey, uint amount, uint refunded)\n        external\n        view\n        returns (uint amountAfterSettlement);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Synthesizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./library/SafeDecimalMath.sol\";\nimport \"./interfaces/ISynth.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IExchanger.sol\";\nimport \"./interfaces/IFeePool.sol\";\nimport \"./interfaces/IRewardEscrow.sol\";\nimport \"./interfaces/IShadows.sol\";\nimport \"./interfaces/ILiquidations.sol\";\n\ncontract Synthesizer is\n    Initializable,\n    OwnableUpgradeable,\n    AddressResolverUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    bytes32 constant xUSD = \"ShaUSD\";\n    uint256 public issuanceRatio;\n\n    ISynth[] public availableSynths;\n    mapping(bytes32 => ISynth) public synths;\n    mapping(address => bytes32) public synthsByAddress;\n\n    struct IssuanceData {\n        // Percentage of the total debt owned at the times\n        uint256 initialDebtOwnership;\n        uint256 debtEntryIndex;\n    }\n\n    mapping(address => IssuanceData) public issuanceData;\n\n    uint256 public totalIssuerCount;\n\n    uint256[] public debtLedger;\n\n    function initialize(address _resolver) external initializer {\n        __Ownable_init();\n        __AddressResolver_init(_resolver);\n        issuanceRatio = SafeDecimalMath.unit() / 5;\n    }\n\n    function debtLedgerLength() public view returns (uint256) {\n        return debtLedger.length;\n    }\n\n    function lastDebtLedgerEntry() public view returns (uint256) {\n        return debtLedger[debtLedger.length - 1];\n    }\n\n    function hasIssued(address account) external view returns (bool) {\n        return issuanceData[account].initialDebtOwnership > 0;\n    }\n\n    function totalIssuedSynths(bytes32 currencyKey)\n        public\n        view\n        returns (uint256)\n    {\n        IOracle oracle = oracle();\n        uint256 total = 0;\n        uint256 currencyRate = oracle.rateForCurrency(currencyKey);\n\n        (uint256[] memory rates, bool anyRateStale) = oracle\n            .ratesAndStaleForCurrencies(availableCurrencyKeys());\n        require(!anyRateStale, \"Rates are stale\");\n\n        for (uint256 i = 0; i < availableSynths.length; i++) {\n            uint256 totalSynths = availableSynths[i].totalSupply();\n            uint256 synthValue = totalSynths.multiplyDecimalRound(rates[i]);\n            total = total.add(synthValue);\n        }\n\n        return total.divideDecimalRound(currencyRate);\n    }\n\n    function availableCurrencyKeys() public view returns (bytes32[] memory) {\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length);\n\n        for (uint256 i = 0; i < availableSynths.length; i++) {\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\n        }\n\n        return currencyKeys;\n    }\n\n    function availableSynthCount() public view returns (uint256) {\n        return availableSynths.length;\n    }\n\n    function addSynth(ISynth synth) external onlyOwner {\n        bytes32 currencyKey = synth.currencyKey();\n\n        require(synths[currencyKey] == ISynth(0), \"Synth already exists\");\n        require(\n            synthsByAddress[address(synth)] == bytes32(0),\n            \"Synth address already exists\"\n        );\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n        synthsByAddress[address(synth)] = currencyKey;\n    }\n\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\n        require(\n            address(synths[currencyKey]) != address(0),\n            \"Synth does not exist\"\n        );\n        require(synths[currencyKey].totalSupply() == 0, \"Synth supply exists\");\n        require(currencyKey != xUSD, \"Cannot remove xUSD\");\n\n        address synthToRemove = address(synths[currencyKey]);\n\n        for (uint256 i = 0; i < availableSynths.length; i++) {\n            if (address(availableSynths[i]) == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[\n                    availableSynths.length - 1\n                ];\n\n                // Decrease the size of the array by one.\n                availableSynths.pop();\n\n                break;\n            }\n        }\n\n        delete synthsByAddress[address(synths[currencyKey])];\n        delete synths[currencyKey];\n    }\n\n    function _issueSynthsFrom(address from, uint256 amount) internal {\n        (uint256 maxIssuable, uint256 existingDebt) = remainingIssuableSynths(\n            from\n        );\n        require(amount <= maxIssuable, \"Amount too large\");\n\n        _addToDebtRegister(from, amount, existingDebt);\n\n        synths[xUSD].issue(from, amount);\n\n        _appendAccountIssuanceRecord(from);\n    }\n\n    function issueSynths(uint256 amount) external {\n        return _issueSynthsFrom(_msgSender(), amount);\n    }\n\n    function issueMaxSynths() external {\n        (uint256 maxIssuable, ) = remainingIssuableSynths(_msgSender());\n\n        return _issueSynthsFrom(_msgSender(), maxIssuable);\n    }\n\n    function burnSynths(uint256 amount) external {\n        address from = _msgSender();\n        uint256 existingDebt = debtBalanceOf(from, xUSD);\n\n        require(existingDebt > 0, \"No debt to forgive\");\n\n        uint256 amountToRemove = existingDebt < amount ? existingDebt : amount;\n\n        _removeFromDebtRegister(from, amountToRemove, existingDebt);\n\n        uint256 amountToBurn = amountToRemove;\n\n        synths[xUSD].burn(from, amountToBurn);\n\n        _appendAccountIssuanceRecord(from);\n    }\n\n    function remainingIssuableSynths(address _issuer)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 alreadyIssued = debtBalanceOf(_issuer, xUSD);\n        uint256 maxIssuable = maxIssuableSynths(_issuer);\n\n        if (alreadyIssued >= maxIssuable) {\n            maxIssuable = 0;\n        } else {\n            maxIssuable = maxIssuable.sub(alreadyIssued);\n        }\n        return (maxIssuable, alreadyIssued);\n    }\n\n    function debtBalanceOf(address _issuer, bytes32 currencyKey)\n        public\n        view\n        returns (uint256)\n    {\n        IssuanceData memory data = issuanceData[_issuer];\n        uint256 initialDebtOwnership = data.initialDebtOwnership;\n        uint256 debtEntryIndex = data.debtEntryIndex;\n\n        if (initialDebtOwnership == 0) return 0;\n\n        // Figure out the global debt percentage delta from when they entered the system.\n        // This is a high precision integer of 27 (1e27) decimals.\n        uint256 currentDebtOwnership = lastDebtLedgerEntry()\n            .divideDecimalRoundPrecise(debtLedger[debtEntryIndex])\n            .multiplyDecimalRoundPrecise(initialDebtOwnership);\n\n        uint256 totalSystemValue = totalIssuedSynths(currencyKey);\n\n        // Their debt balance is their portion of the total system value.\n        uint256 highPrecisionBalance = totalSystemValue\n            .decimalToPreciseDecimal()\n            .multiplyDecimalRoundPrecise(currentDebtOwnership);\n\n        // Convert back into 18 decimals (1e18)\n        return highPrecisionBalance.preciseDecimalToDecimal();\n    }\n\n    function maxIssuableSynths(address _issuer) public view returns (uint256) {\n        // What is the value of their DOWS balance in the destination currency?\n        uint256 destinationValue = oracle().effectiveValue(\n            \"DOWS\",\n            collateral(_issuer),\n            xUSD\n        );\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return destinationValue.multiplyDecimal(issuanceRatio);\n    }\n\n    function collateralisationRatio(address _issuer)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 totalOwnedShadows = collateral(_issuer);\n        if (totalOwnedShadows == 0) return 0;\n\n        uint256 debtBalance = debtBalanceOf(_issuer, \"DOWS\");\n        return debtBalance.divideDecimalRound(totalOwnedShadows);\n    }\n\n    function collateral(address account) public view returns (uint256) {\n        uint256 balance = shadows().balanceOf(account);\n\n        if (address(rewardEscrow()) != address(0)) {\n            balance = balance.add(rewardEscrow().balanceOf(account));\n        }\n\n        return balance;\n    }\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint256 sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint256 amountReceived) {\n        return\n            exchanger().exchange(\n                _msgSender(),\n                sourceCurrencyKey,\n                sourceAmount,\n                destinationCurrencyKey,\n                _msgSender()\n            );\n    }\n\n    function transferableShadows(address account)\n        public\n        view\n        rateNotStale(\"DOWS\")\n        returns (uint256)\n    {\n        uint256 balance = shadows().balanceOf(account);\n\n        uint256 lockedShadowsValue = debtBalanceOf(account, \"DOWS\")\n            .divideDecimalRound(issuanceRatio);\n\n        if (lockedShadowsValue >= balance) {\n            return 0;\n        } else {\n            return balance.sub(lockedShadowsValue);\n        }\n    }\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint256 susdAmount,\n        address liquidator\n    )\n        external\n        rateNotStale(\"DOWS\")\n        returns (uint256 totalRedeemed, uint256 amountToLiquidate)\n    {\n        // Ensure waitingPeriod and xUSD balance is settled as burning impacts the size of debt pool\n        ILiquidations _liquidations = liquidations();\n\n        // Check account is liquidation open\n        require(\n            _liquidations.isOpenForLiquidation(account),\n            \"Account not open for liquidation\"\n        );\n\n        // require liquidator has enough xUSD\n        require(\n            IERC20(address(synths[xUSD])).balanceOf(liquidator) >= susdAmount,\n            \"Not enough xUSD\"\n        );\n\n        uint256 liquidationPenalty = _liquidations.liquidationPenalty();\n\n        uint256 accountCollateral = collateral(account);\n\n        // What is the value of their DOWS balance in xUSD?\n        uint256 collateralValue = oracle().effectiveValue(\n            \"DOWS\",\n            accountCollateral,\n            xUSD\n        );\n\n        // What is their debt in xUSD?\n        uint256 debtBalance = debtBalanceOf(account, xUSD);\n\n        uint256 amountToFixRatio = _liquidations.calculateAmountToFixCollateral(\n            debtBalance,\n            collateralValue\n        );\n\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\n        amountToLiquidate = amountToFixRatio < susdAmount\n            ? amountToFixRatio\n            : susdAmount;\n\n        // what's the equivalent amount of DOWS for the amountToLiquidate?\n        uint256 dowsRedeemed = oracle().effectiveValue(\n            xUSD,\n            amountToLiquidate,\n            \"DOWS\"\n        );\n\n        // Add penalty\n        totalRedeemed = dowsRedeemed.multiplyDecimal(\n            SafeDecimalMath.unit().add(liquidationPenalty)\n        );\n\n        // if total DOWS to redeem is greater than account's collateral\n        // account is under collateralised, liquidate all collateral and reduce xUSD to burn\n        // an insurance fund will be added to cover these undercollateralised positions\n        if (totalRedeemed > accountCollateral) {\n            // set totalRedeemed to all collateral\n            totalRedeemed = accountCollateral;\n\n            // whats the equivalent xUSD to burn for all collateral less penalty\n            amountToLiquidate = oracle().effectiveValue(\n                \"DOWS\",\n                accountCollateral.divideDecimal(\n                    SafeDecimalMath.unit().add(liquidationPenalty)\n                ),\n                xUSD\n            );\n        }\n\n        // burn xUSD from messageSender (liquidator) and reduce account's debt\n        _burnSynthsForLiquidation(\n            account,\n            liquidator,\n            amountToLiquidate,\n            debtBalance,\n            totalRedeemed\n        );\n\n        if (amountToLiquidate == amountToFixRatio) {\n            // Remove liquidation\n            _liquidations.removeAccountInLiquidation(account);\n        }\n    }\n\n    function _burnSynthsForLiquidation(\n        address burnForAddress,\n        address liquidator,\n        uint256 amount,\n        uint256 existingDebt,\n        uint256 totalRedeemed\n    ) internal {\n        // liquidation requires sUSD to be already settled / not in waiting period\n        uint256 amountBurnt = existingDebt < amount ? existingDebt : amount;\n\n        // Remove liquidated debt from the ledger\n        _removeFromDebtRegister(burnForAddress, amountBurnt, existingDebt);\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        require(\n            IERC20(address(synths[xUSD])).balanceOf(liquidator) >= amountBurnt,\n            \"Liquidator Not enough xUSD\"\n        );\n        ISynth(address(synths[xUSD])).burn(liquidator, amount);\n\n        // Store their debtRatio against a feeperiod to determine their fee/rewards % for the period\n        _appendAccountIssuanceRecord(burnForAddress);\n    }\n\n    function _addToDebtRegister(\n        address from,\n        uint256 amount,\n        uint256 existingDebt\n    ) internal {\n        uint256 totalDebtIssued = totalIssuedSynths(xUSD);\n\n        uint256 newTotalDebtIssued = amount.add(totalDebtIssued);\n\n        uint256 debtPercentage = amount.divideDecimalRoundPrecise(\n            newTotalDebtIssued\n        );\n\n        // And what effect does this percentage change have on the global debt holding of other issuers?\n        // The delta specifically needs to not take into account any existing debt as it's already\n        // accounted for in the delta from when they issued previously.\n        // The delta is a high precision integer.\n        uint256 delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n        // And what does their debt ownership look like including this previous stake?\n        if (existingDebt > 0) {\n            debtPercentage = amount.add(existingDebt).divideDecimalRoundPrecise(\n                    newTotalDebtIssued\n                );\n        }\n\n        // Are they a new issuer? If so, record them.\n        if (existingDebt == 0) {\n            _incrementTotalIssuerCount();\n        }\n\n        // Save the debt entry parameters\n        _setCurrentIssuanceData(from, debtPercentage);\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n        if (debtLedgerLength() > 0) {\n            _appendDebtLedgerValue(\n                lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n            );\n        } else {\n            _appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\n        }\n    }\n\n    function _removeFromDebtRegister(\n        address from,\n        uint256 amount,\n        uint256 existingDebt\n    ) internal {\n        uint256 debtToRemove = amount;\n\n        uint256 totalDebtIssued = totalIssuedSynths(xUSD);\n\n        uint256 newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\n\n        uint256 delta = 0;\n\n        // What will the debt delta be if there is any debt left?\n        // Set delta to 0 if no more debt left in system after user\n        if (newTotalDebtIssued > 0) {\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\n            uint256 debtPercentage = debtToRemove.divideDecimalRoundPrecise(\n                newTotalDebtIssued\n            );\n\n            // And what effect does this percentage change have on the global debt holding of other issuers?\n            // The delta specifically needs to not take into account any existing debt as it's already\n            // accounted for in the delta from when they issued previously.\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\n        }\n\n        // Are they exiting the system, or are they just decreasing their debt position?\n        if (debtToRemove == existingDebt) {\n            _setCurrentIssuanceData(from, 0);\n            _decrementTotalIssuerCount();\n        } else {\n            // What percentage of the debt will they be left with?\n            uint256 newDebt = existingDebt.sub(debtToRemove);\n            uint256 newDebtPercentage = newDebt.divideDecimalRoundPrecise(\n                newTotalDebtIssued\n            );\n\n            // Store the debt percentage and debt ledger as high precision integers\n            _setCurrentIssuanceData(from, newDebtPercentage);\n        }\n\n        // Update our cumulative ledger. This is also a high precision integer.\n        _appendDebtLedgerValue(\n            lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta)\n        );\n    }\n\n    function _appendAccountIssuanceRecord(address from) internal {\n        IssuanceData memory data = issuanceData[from];\n\n        feePool().appendAccountIssuanceRecord(\n            from,\n            data.initialDebtOwnership,\n            data.debtEntryIndex\n        );\n    }\n\n    function _setCurrentIssuanceData(\n        address account,\n        uint256 initialDebtOwnership\n    ) internal {\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n    }\n\n    function _incrementTotalIssuerCount() internal {\n        totalIssuerCount = totalIssuerCount.add(0);\n    }\n\n    function _decrementTotalIssuerCount() internal {\n        totalIssuerCount = totalIssuerCount.sub(0);\n    }\n\n    function _appendDebtLedgerValue(uint256 value) internal {\n        debtLedger.push(value);\n    }\n\n    function setIssuanceRatio(uint256 _issuanceRatio) external onlyOwner {\n        require(\n            _issuanceRatio <= SafeDecimalMath.unit(),\n            \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\"\n        );\n        issuanceRatio = _issuanceRatio;\n        emit IssuanceRatioUpdated(_issuanceRatio);\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return\n            IExchanger(\n                resolver.requireAndGetAddress(\n                    \"Exchanger\",\n                    \"Missing Exchanger address\"\n                )\n            );\n    }\n\n    function oracle() internal view returns (IOracle) {\n        return\n            IOracle(\n                resolver.requireAndGetAddress(\n                    \"Oracle\",\n                    \"Missing Oracle address\"\n                )\n            );\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return\n            IFeePool(\n                resolver.requireAndGetAddress(\n                    \"FeePool\",\n                    \"Missing FeePool address\"\n                )\n            );\n    }\n\n    function rewardEscrow() internal view returns (IRewardEscrow) {\n        return\n            IRewardEscrow(\n                resolver.requireAndGetAddress(\n                    \"RewardEscrow\",\n                    \"Missing RewardEscrow address\"\n                )\n            );\n    }\n\n    function shadows() internal view returns (IShadows) {\n        return\n            IShadows(\n                resolver.requireAndGetAddress(\n                    \"Shadows\",\n                    \"Missing Shadows address\"\n                )\n            );\n    }\n\n    function liquidations() internal view returns (ILiquidations) {\n        return\n            ILiquidations(\n                resolver.requireAndGetAddress(\n                    \"Liquidations\",\n                    \"Missing Liquidations address\"\n                )\n            );\n    }\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(\n            !oracle().rateIsStale(currencyKey),\n            \"Rate stale or not a synth\"\n        );\n        _;\n    }\n\n    event IssuanceRatioUpdated(uint256 newRatio);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/ISynth.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\n\nabstract contract ISynth {\n    bytes32 public currencyKey;\n\n    function totalSupply() virtual external view returns (uint256);\n\n    function burn(address account, uint amount) virtual external;\n\n    function issue(address account, uint amount) virtual external;\n\n    function transfer(address to, uint value) virtual external returns (bool);\n\n    function transferFrom(address from, address to, uint value) virtual external returns (bool);\n\n    function balanceOf(address owner) virtual external view returns (uint);\n}"
    },
    "contracts/interfaces/IRewardEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title RewardEscrow interface\n */\ninterface IRewardEscrow {\n    function balanceOf(address account) external view returns (uint);\n    function vestBalanceOf(address account) external view returns (uint);\n    function appendVestingEntry(address account, uint quantity) external;\n}\n"
    },
    "contracts/interfaces/IShadows.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\nabstract contract IShadows {\n    uint256 public totalSupply;\n\n    uint256 public issuanceRatio;\n\n    function balanceOf(address account) external view virtual returns (uint256);\n\n    function transfer(address to, uint256 value)\n        external\n        virtual\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external virtual returns (bool);\n}"
    },
    "contracts/interfaces/ILiquidations.sol": {
      "content": "// SPDX-License-Identifier: MI\npragma solidity >=0.6.0 <0.8.0;\n\ninterface ILiquidations {\n    function isOpenForLiquidation(address account) external view returns (bool);\n\n    function getLiquidationDeadlineForAccount(address account)\n        external\n        view\n        returns (uint256);\n\n    function isLiquidationDeadlinePassed(address account)\n        external\n        view\n        returns (bool);\n\n    function liquidationDelay() external view returns (uint256);\n\n    function liquidationRatio() external view returns (uint256);\n\n    function liquidationPenalty() external view returns (uint256);\n\n    function calculateAmountToFixCollateral(\n        uint256 debtBalance,\n        uint256 collateral\n    ) external view returns (uint256);\n\n    // Mutative Functions\n    function flagAccountForLiquidation(address account) external;\n\n    // Restricted: used internally to Synthetix\n    function removeAccountInLiquidation(address account) external;\n\n    function checkAndRemoveAccountInLiquidation(address account) external;\n}\n"
    },
    "contracts/RewardEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./library/SafeDecimalMath.sol\";\nimport \"./interfaces/IFeePool.sol\";\nimport \"./interfaces/IShadows.sol\";\n\n/*\nDOWS rewards are escrowed for 1 year from the claim date and users\ncan call vest in 6 months time.\n*/\ncontract RewardEscrow is\n    Initializable,\n    OwnableUpgradeable,\n    AddressResolverUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of DOWS vests. */\n    mapping(address => uint256[2][]) public vestingSchedules;\n\n    /* An account's total escrowed shadows balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint256) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward shadows. */\n    mapping(address => uint256) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual shadows balance of this contract against. */\n    uint256 public totalEscrowedBalance;\n\n    uint256 constant TIME_INDEX = 0;\n    uint256 constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint256 public constant MAX_VESTING_ENTRIES = 52 * 5;\n    uint256 public vestingScheduleTime;\n\n    function initialize(address _resolver) external initializer {\n        __Ownable_init();\n        __AddressResolver_init(_resolver);\n        vestingScheduleTime = 4 weeks;\n    }\n\n    function setVestingScheduleTime(uint256 _vestingScheduleTime) public onlyOwner {\n        vestingScheduleTime = _vestingScheduleTime;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    function vestBalanceOf(address account) public view returns (uint256) {\n        return totalVestedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint256) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, shadows quantity).\n     */\n    function getVestingScheduleEntry(address account, uint256 index)\n        public\n        view\n        returns (uint256[2] memory)\n    {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of DOWS associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 len = numVestingEntries(account);\n        for (uint256 i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, shadows quantity). */\n    function getNextVestingEntry(address account)\n        public\n        view\n        returns (uint256[2] memory)\n    {\n        uint256 index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint256(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account)\n        public\n        view\n        returns (uint256[520] memory)\n    {\n        uint256[520] memory _result;\n        uint256 schedules = numVestingEntries(account);\n        for (uint256 i = 0; i < schedules; i++) {\n            uint256[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to shadows.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of DOWS that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint256 quantity)\n        public\n        onlyFeePool\n    {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= shadows().balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint256 scheduleLength = vestingSchedules[account].length;\n        require(\n            scheduleLength <= MAX_VESTING_ENTRIES,\n            \"Vesting schedule is too long\"\n        );\n\n        /* Escrow the tokens for 1 year. */\n        uint256 time = block.timestamp + vestingScheduleTime;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested DOWS earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[\n                account\n            ]\n                .add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, block.timestamp, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any DOWS in their schedule that have vested.\n     */\n    function vest() external {\n        uint256 numEntries = numVestingEntries(msg.sender);\n        uint256 total;\n        for (uint256 i = 0; i < numEntries; i++) {\n            uint256 time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > block.timestamp) {\n                break;\n            }\n            uint256 qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[\n                msg.sender\n            ] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[\n                msg.sender\n            ]\n                .add(total);\n            shadows().transfer(msg.sender, total);\n            emit Vested(msg.sender, block.timestamp, total);\n        }\n    }\n\n    function shadows() internal view returns (IShadows) {\n        return\n            IShadows(\n                resolver.requireAndGetAddress(\n                    \"Shadows\",\n                    \"Missing Shadows address\"\n                )\n            );\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return\n            IFeePool(\n                resolver.requireAndGetAddress(\n                    \"FeePool\",\n                    \"Missing FeePool address\"\n                )\n            );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool());\n\n        require(\n            isFeePool,\n            \"Only the FeePool contracts can perform this action\"\n        );\n        _;\n    }\n\n    event Vested(address indexed beneficiary, uint256 time, uint256 value);\n\n    event VestingEntryCreated(\n        address indexed beneficiary,\n        uint256 time,\n        uint256 value\n    );\n}\n"
    },
    "contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol\";\nimport \"./library/SafeDecimalMath.sol\";\n\ncontract Oracle is Initializable, OwnableUpgradeable {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 private constant xUSD = \"ShaUSD\";\n\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Exchange rates and update times stored by currency code, e.g. 'DOWS', or 'xUSD'\n    mapping(bytes32 => mapping(uint => RateAndUpdatedTime)) private _rates;\n\n    // The address of the oracle which pushes rate updates to this contract\n    address public oracle;\n\n    // Decentralized oracle networks that feed into pricing aggregators\n    mapping(bytes32 => AggregatorV2V3Interface) public aggregators;\n\n    // List of aggregator keys for convenient iteration\n    bytes32[] public aggregatorKeys;\n\n    // Do not allow the oracle to submit times any further forward into the future than this constant.\n    uint private constant ORACLE_FUTURE_LIMIT = 10 minutes;\n\n    // How long will the contract assume the rate of any asset is correct\n    uint public rateStalePeriod;\n\n    mapping(bytes32 => uint) currentRoundForRate;\n\n    function initialize(\n        address _oracle,\n        bytes32[] calldata _currencyKeys,\n        uint[] calldata _newRates \n    ) external initializer {\n        __Ownable_init();\n        require(_currencyKeys.length == _newRates.length, \"Currency key length and rate length must match.\");\n\n        oracle = _oracle;\n\n        // The xUSD rate is always 1 and is never stale.\n        _setRate(xUSD, SafeDecimalMath.unit(), block.timestamp);\n\n        internalUpdateRates(_currencyKeys, _newRates, block.timestamp);\n\n        rateStalePeriod = 3 hours;\n    }\n\n    function updateRates(bytes32[] calldata currencyKeys, uint[] calldata newRates, uint timeSent) external onlyOracle returns (bool) {\n        return internalUpdateRates(currencyKeys, newRates, timeSent);\n    }\n\n    function deleteRate(bytes32 currencyKey) external onlyOracle {\n        require(getRate(currencyKey) > 0, \"Rate is zero\");\n\n        delete _rates[currencyKey][currentRoundForRate[currencyKey]];\n\n        currentRoundForRate[currencyKey]--;\n\n        emit RateDeleted(currencyKey);\n    }\n\n\n    /**\n     * @notice Add a pricing aggregator for the given key. Note: existing aggregators may be overridden.\n     */\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\n        AggregatorV2V3Interface aggregator = AggregatorV2V3Interface(aggregatorAddress);\n        require(aggregator.latestTimestamp() >= 0, \"Given Aggregator is invalid\");\n        if (address(aggregators[currencyKey]) == address(0)) {\n            aggregatorKeys.push(currencyKey);\n        }\n        aggregators[currencyKey] = aggregator;\n        emit AggregatorAdded(currencyKey, address(aggregator));\n    }\n\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\n        address aggregator = address(aggregators[currencyKey]);\n        require(aggregator != address(0), \"No aggregator exists for key\");\n        delete aggregators[currencyKey];\n\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\n\n        if (wasRemoved) {\n            emit AggregatorRemoved(currencyKey, aggregator);\n        }\n    }\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint) {\n        uint roundId = startingRoundId;\n        uint nextTimestamp = 0;\n        while (true) {\n            (, nextTimestamp) = getRateAndTimestampAtRound(currencyKey, roundId + 1);\n            // if there's no new round, then the previous roundId was the latest\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\n                return roundId;\n            }\n            roundId++;\n        }\n        return roundId;\n    }\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\n        if (address(aggregators[currencyKey]) != address(0)) {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            return aggregator.latestRound();\n        } else {\n            return currentRoundForRate[currencyKey];\n        }\n    }\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint) {\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\n\n        (uint srcRate, ) = getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\n        (uint destRate, ) = getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\n        // Calculate the effective value by going from source -> USD -> destination\n        return sourceAmount.multiplyDecimalRound(srcRate).divideDecimalRound(destRate);\n    }\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\n        return getRateAndTimestampAtRound(currencyKey, roundId);\n    }\n\n    function lastRateUpdateTimes(bytes32 currencyKey) public view returns (uint256) {\n        return getRateAndUpdatedTime(currencyKey).time;\n    }\n\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) public view returns (uint[] memory) {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = lastRateUpdateTimes(currencyKeys[i]);\n        }\n\n        return lastUpdateTimes;\n    }\n\n    function effectiveValue(bytes32 sourceCurrencyKey, uint sourceAmount, bytes32 destinationCurrencyKey)\n        public\n        view\n        rateNotStale(sourceCurrencyKey)\n        rateNotStale(destinationCurrencyKey)\n        returns (uint)\n    {\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\n\n        // Calculate the effective value by going from source -> USD -> destination\n        return\n            sourceAmount.multiplyDecimalRound(getRate(sourceCurrencyKey)).divideDecimalRound(\n                getRate(destinationCurrencyKey)\n            );\n    }\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\n        return getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            _localRates[i] = getRate(currencyKeys[i]);\n        }\n\n        return _localRates;\n    }\n\n    function ratesAndStaleForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory, bool) {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        bool anyRateStale = false;\n        uint period = rateStalePeriod;\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            RateAndUpdatedTime memory rateAndUpdateTime = getRateAndUpdatedTime(currencyKeys[i]);\n            _localRates[i] = uint256(rateAndUpdateTime.rate);\n            if (!anyRateStale) {\n                anyRateStale = (currencyKeys[i] != xUSD && uint256(rateAndUpdateTime.time).add(period) < block.timestamp);\n            }\n        }\n\n        return (_localRates, anyRateStale);\n    }\n\n    function rateIsStale(bytes32 currencyKey) public view returns (bool) {\n        // xUSD is a special case and is never stale.\n        if (currencyKey == xUSD) return false;\n\n        return lastRateUpdateTimes(currencyKey).add(rateStalePeriod) < block.timestamp;\n    }\n\n    function anyRateIsStale(bytes32[] calldata currencyKeys) external view returns (bool) {\n        // Loop through each key and check whether the data point is stale.\n        uint256 i = 0;\n\n        while (i < currencyKeys.length) {\n            // xUSD is a special case and is never false\n            if (currencyKeys[i] != xUSD && lastRateUpdateTimes(currencyKeys[i]).add(rateStalePeriod) < block.timestamp) {\n                return true;\n            }\n            i += 1;\n        }\n\n        return false;\n    }\n\n    function _setRate(bytes32 currencyKey, uint256 rate, uint256 time) internal {\n        // Note: this will effectively start the rounds at 1, which matches Chainlink's Agggregators\n        currentRoundForRate[currencyKey]++;\n\n        _rates[currencyKey][currentRoundForRate[currencyKey]] = RateAndUpdatedTime({\n            rate: uint216(rate),\n            time: uint40(time)\n        });\n    }\n\n    function internalUpdateRates(bytes32[] calldata currencyKeys, uint[] calldata newRates, uint timeSent) internal returns (bool) {\n        require(currencyKeys.length == newRates.length, \"Currency key array length must match rates array length.\");\n        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), \"Time is too far into the future\");\n\n        // Loop through each key and perform update.\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n\n            // Should not set any rate to zero ever, as no asset will ever be\n            // truely worthless and still valid. In this scenario, we should\n            // delete the rate and remove it from the system.\n            require(newRates[i] != 0, \"Zero is not a valid rate, please call deleteRate instead.\");\n            require(currencyKey != xUSD, \"Rate of xUSD cannot be updated, it's always UNIT.\");\n\n            // We should only update the rate if it's at least the same age as the last rate we've got.\n            if (timeSent < lastRateUpdateTimes(currencyKey)) {\n                continue;\n            }\n\n            // Ok, go ahead with the update.\n            _setRate(currencyKey, newRates[i], timeSent);\n        }\n\n        emit RatesUpdated(currencyKeys, newRates);\n\n        return true;\n    }\n\n\n    function getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\n        if (address(aggregators[currencyKey]) != address(0)) {\n            return\n                RateAndUpdatedTime({\n                    rate: uint216(aggregators[currencyKey].latestAnswer() * 1e10),\n                    time: uint40(aggregators[currencyKey].latestTimestamp())\n                });\n        } else {\n            return _rates[currencyKey][currentRoundForRate[currencyKey]];\n        }\n    }\n\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == entry) {\n                delete array[i];\n\n                array[i] = array[array.length - 1];\n\n                array.pop();\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\n        if (address(aggregators[currencyKey]) != address(0)) {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            return (uint(aggregator.getAnswer(roundId) * 1e10), aggregator.getTimestamp(roundId));\n        } else {\n            RateAndUpdatedTime storage update = _rates[currencyKey][roundId];\n            return (update.rate, update.time);\n        }\n    }\n\n    function getRate(bytes32 currencyKey) internal view returns (uint256) {\n        return getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    function setOracle(address _oracle) external onlyOwner {\n        oracle = _oracle;\n        emit OracleUpdated(oracle);\n    }\n\n    function setRateStalePeriod(uint _time) external onlyOwner {\n        rateStalePeriod = _time;\n        emit RateStalePeriodUpdated(rateStalePeriod);\n    }\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(!rateIsStale(currencyKey), \"Rate stale or nonexistant currency\");\n        _;\n    }\n\n    modifier onlyOracle {\n        require(msg.sender == oracle, \"Only the oracle can perform this action\");\n        _;\n    }\n\n    event OracleUpdated(address newOracle);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    event RatesUpdated(bytes32[] currencyKeys, uint[] newRates);\n    event RateDeleted(bytes32 currencyKey);\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"../../utils/PausableUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Shadows.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./interfaces/ISynthesizer.sol\";\n\ncontract Shadows is\n    Initializable,\n    OwnableUpgradeable,\n    ERC20PausableUpgradeable\n{\n    // Maximum Total Supply 100 M\n    uint256 constant maxTotalSupply = 1e8 ether;\n\n    ISynthesizer public synthesizer;\n\n    function initialize() external initializer {\n        __Ownable_init();\n        __ERC20_init(\"Shadows\", \"DOWS\");\n        __ERC20Pausable_init();\n        _mint(_msgSender(), 37000000 ether);\n    }\n\n    function liquidateDelinquentAccount(address account, uint256 susdAmount)\n        external\n    {\n        require(\n            address(synthesizer) != address(0),\n            \"Missing Synthesizer address\"\n        );\n        (uint256 totalRedeemed, uint256 amountLiquidated) = synthesizer\n        .liquidateDelinquentAccount(account, susdAmount, _msgSender());\n\n        emit AccountLiquidated(\n            account,\n            totalRedeemed,\n            amountLiquidated,\n            _msgSender()\n        );\n\n        // Transfer DOWS redeemed to messageSender\n        // Reverts if amount to redeem is more than balanceOf account, ie due to escrowed balance\n        _transfer(account, _msgSender(), totalRedeemed);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        if (address(synthesizer) != address(0)) {\n            require(\n                amount <= synthesizer.transferableShadows(_msgSender()),\n                \"Cannot transfer staked DOWS\"\n            );\n        }\n        super.transfer(recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (address(synthesizer) != address(0)) {\n            require(\n                amount <= synthesizer.transferableShadows(sender),\n                \"Cannot transfer staked DOWS\"\n            );\n        }\n        super.transferFrom(sender, recipient, amount);\n        return true;\n    }\n\n    function _beforeTokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        // if (address(synthesizer) != address(0)) {\n        //     require(\n        //         amount <= synthesizer.transferableShadows(sender),\n        //         \"Cannot transfer staked DOWS\"\n        //     );\n        // }\n        return super._beforeTokenTransfer(sender, recipient, amount);\n    }\n\n    function mint(address account, uint256 amount) external onlyOwner {\n        _mint(account, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal override {\n        uint256 totalSupply = super.totalSupply();\n        require(\n            maxTotalSupply >= totalSupply + amount,\n            \"Max total supply over\"\n        );\n\n        super._mint(account, amount);\n    }\n\n    function setSynthesizer(ISynthesizer _synthesizer) external onlyOwner {\n        // require(\n        // address(_synthesizer) != address(0),\n        //    \"synthesizer can not be zero address\"\n        // );\n        synthesizer = _synthesizer;\n        emit SynthesizerUpdated(_synthesizer);\n    }\n\n    event SynthesizerUpdated(ISynthesizer _synthesizer);\n    event AccountLiquidated(\n        address indexed account,\n        uint256 dowsRedeemed,\n        uint256 amountLiquidated,\n        address liquidator\n    );\n}\n"
    },
    "contracts/Liquidations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./library/SafeDecimalMath.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./interfaces/ISynthesizer.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract Liquidations is\n    Initializable,\n    OwnableUpgradeable,\n    AddressResolverUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    struct LiquidationEntry {\n        uint256 deadline;\n        address caller;\n    }\n\n    mapping(address => uint256) public liquidationDeadlineStorage;\n\n    uint256 public liquidationPenalty;\n    uint256 public liquidationRatio;\n    uint256 public liquidationDelay;\n\n    function initialize(address _resolver) external initializer {\n        __Ownable_init();\n        __AddressResolver_init(_resolver);\n        liquidationPenalty = 1e18 / 10; // 10%\n        liquidationDelay = 2 hours;\n        liquidationRatio = 1e18 / 2;\n    }\n\n    function getLiquidationDeadlineForAccount(address account)\n        external\n        view\n        returns (uint256)\n    {\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n        return liquidation.deadline;\n    }\n\n    function isOpenForLiquidation(address account)\n        external\n        view\n        returns (bool)\n    {\n        uint256 accountCollateralisationRatio =\n            synthesizer().collateralisationRatio(account);\n\n        // Liquidation closed if collateral ratio less than or equal target issuance Ratio\n        // Account with no dows collateral will also not be open for liquidation (ratio is 0)\n        if (accountCollateralisationRatio <= synthesizer().issuanceRatio()) {\n            return false;\n        }\n\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n\n        // liquidation cap at issuanceRatio is checked above\n        if (_deadlinePassed(liquidation.deadline)) {\n            return true;\n        }\n        return false;\n    }\n\n    function isLiquidationDeadlinePassed(address account)\n        external\n        view\n        returns (bool)\n    {\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n        return _deadlinePassed(liquidation.deadline);\n    }\n\n    function _deadlinePassed(uint256 deadline) internal view returns (bool) {\n        // check deadline is set > 0\n        // check now > deadline\n        return deadline > 0 && block.timestamp > deadline;\n    }\n\n    /**\n     * r = target issuance ratio\n     * D = debt balance\n     * V = Collateral\n     * P = liquidation penalty\n     * Calculates amount of synths = (D - V * r) / (1 - (1 + P) * r)\n     */\n    function calculateAmountToFixCollateral(\n        uint256 debtBalance,\n        uint256 collateral\n    ) external view returns (uint256) {\n        uint256 ratio = synthesizer().issuanceRatio();\n        uint256 unit = SafeDecimalMath.unit();\n\n        uint256 dividend = debtBalance.sub(collateral.multiplyDecimal(ratio));\n        uint256 divisor =\n            unit.sub(unit.add(liquidationPenalty).multiplyDecimal(ratio));\n\n        return dividend.divideDecimal(divisor);\n    }\n\n    function flagAccountForLiquidation(address account)\n        external\n        rateNotStale(\"DOWS\")\n    {\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n        require(\n            liquidation.deadline == 0,\n            \"Account already flagged for liquidation\"\n        );\n\n        uint256 accountsCollateralisationRatio =\n            synthesizer().collateralisationRatio(account);\n\n        // if accounts issuance ratio is greater than or equal to liquidation ratio set liquidation entry\n        require(\n            accountsCollateralisationRatio >= liquidationRatio,\n            \"Account issuance ratio is less than liquidation ratio\"\n        );\n\n        uint256 deadline = block.timestamp.add(liquidationDelay);\n\n        _storeLiquidationEntry(account, deadline, msg.sender);\n\n        emit AccountFlaggedForLiquidation(account, deadline);\n    }\n\n    // Internal function to remove account from liquidations\n    // Does not check collateral ratio is fixed\n    function removeAccountInLiquidation(address account)\n        external\n        onlySynthesizer\n    {\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n        if (liquidation.deadline > 0) {\n            _removeLiquidationEntry(account);\n        }\n    }\n\n    // Public function to allow an account to remove from liquidations\n    // Checks collateral ratio is fixed - below target issuance ratio\n    // Check DOWS rate is not stale\n    function checkAndRemoveAccountInLiquidation(address account)\n        external\n        rateNotStale(\"DOWS\")\n    {\n        LiquidationEntry memory liquidation =\n            _getLiquidationEntryForAccount(account);\n\n        require(liquidation.deadline > 0, \"Account has no liquidation set\");\n\n        uint256 accountsCollateralisationRatio =\n            synthesizer().collateralisationRatio(account);\n\n        // Remove from liquidations if accountsCollateralisationRatio is fixed (less than equal target issuance ratio)\n        if (accountsCollateralisationRatio <= synthesizer().issuanceRatio()) {\n            _removeLiquidationEntry(account);\n        }\n    }\n\n    function _storeLiquidationEntry(\n        address _account,\n        uint256 _deadline,\n        address _caller\n    ) internal {\n        // record liquidation deadline\n        liquidationDeadlineStorage[_account] = _deadline;\n    }\n\n    function _removeLiquidationEntry(address _account) internal {\n        // delete liquidation deadline\n        delete liquidationDeadlineStorage[_account];\n        emit AccountRemovedFromLiquidation(_account, block.timestamp);\n    }\n\n    // get liquidationEntry for account\n    // returns deadline = 0 when not set\n    function _getLiquidationEntryForAccount(address account)\n        internal\n        view\n        returns (LiquidationEntry memory _liquidation)\n    {\n        _liquidation.deadline = liquidationDeadlineStorage[account];\n    }\n\n    function synthesizer() internal view returns (ISynthesizer) {\n        return\n            ISynthesizer(\n                resolver.requireAndGetAddress(\n                    \"Synthesizer\",\n                    \"Missing Synthesizer address\"\n                )\n            );\n    }\n\n    function oracle() internal view returns (IOracle) {\n        return\n            IOracle(\n                resolver.requireAndGetAddress(\n                    \"Oracle\",\n                    \"Missing Oracle address\"\n                )\n            );\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return\n            IExchanger(\n                resolver.requireAndGetAddress(\n                    \"Exchanger\",\n                    \"Missing Exchanger address\"\n                )\n            );\n    }\n\n    /* ========== SETTERS ========== */\n    function setLiquidationDelay(uint256 time) external onlyOwner {\n        liquidationDelay = time;\n    }\n\n    // Accounts Collateral/Issuance ratio is higher when there is less collateral backing their debt\n    // Upper bound liquidationRatio is 1 + penalty (100% + 10% = 110%) to allow collateral to cover debt and penalty\n    function setLiquidationRatio(uint256 _liquidationRatio) external onlyOwner {\n        liquidationRatio = _liquidationRatio;\n    }\n\n    function setLiquidationPenalty(uint256 penalty) external onlyOwner {\n        liquidationPenalty = penalty;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier rateNotStale(bytes32 currencyKey) {\n        require(\n            !oracle().rateIsStale(currencyKey),\n            \"Rate stale or not a synth\"\n        );\n        _;\n    }\n\n    modifier onlySynthesizer {\n        require(\n            msg.sender == address(synthesizer()),\n            \"FeePool: Only Issuer Authorised\"\n        );\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AccountFlaggedForLiquidation(\n        address indexed account,\n        uint256 deadline\n    );\n    event AccountRemovedFromLiquidation(address indexed account, uint256 time);\n}\n"
    },
    "contracts/FeePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"./library/AddressResolverUpgradeable.sol\";\nimport \"./library/SafeDecimalMath.sol\";\nimport \"./interfaces/ISynthesizer.sol\";\nimport \"./interfaces/IRewardEscrow.sol\";\n\ncontract FeePool is\n    Initializable,\n    OwnableUpgradeable,\n    AddressResolverUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeDecimalMath for uint256;\n\n    address public feePool;\n\n    // The IssuanceData activity that's happened in a fee period.\n    struct IssuanceData {\n        uint256 debtPercentage;\n        uint256 debtEntryIndex;\n    }\n\n    uint8 public constant FEE_PERIOD_LENGTH = 3;\n\n    uint256 public BONUS_REWARDS;\n\n    mapping(address => uint256) lastFeeWithdrawalStorage;\n\n    // The IssuanceData activity that's happened in a fee period.\n    mapping(address => IssuanceData[FEE_PERIOD_LENGTH])\n        public accountIssuanceLedger;\n\n    uint256 public exchangeFeeRate;\n\n    address public constant FEE_ADDRESS =\n        0x06674B0236E817140b3e62134841BF724E08a793;\n\n    bytes32 private constant xUSD = \"ShaUSD\";\n\n    // This struct represents the issuance activity that's happened in a fee period.\n    struct FeePeriod {\n        uint64 feePeriodId;\n        uint64 startingDebtIndex;\n        uint64 startTime;\n        uint256 feesToDistribute;\n        uint256 feesClaimed;\n        uint256 rewardsToDistribute;\n        uint256 rewardsClaimed;\n    }\n\n    FeePeriod[FEE_PERIOD_LENGTH] private _recentFeePeriods;\n    uint256 private _currentFeePeriod;\n\n    uint256 public feePeriodDuration;\n\n    // Users are unable to claim fees if their collateralisation ratio drifts out of target treshold\n    uint256 public targetThreshold;\n\n    function initialize(uint256 _exchangeFeeRate, address _resolver)\n        external\n        initializer\n    {\n        require(\n            _exchangeFeeRate < SafeDecimalMath.unit() / 10,\n            \"rate < MAX_EXCHANGE_FEE_RATE\"\n        );\n        __Ownable_init();\n        __AddressResolver_init(_resolver);\n        feePeriodDuration = 1 weeks;\n        exchangeFeeRate = _exchangeFeeRate;\n        BONUS_REWARDS = 1;\n    }\n\n    function setRewardsMultiplier(uint256 multiplierNumber) public onlyOwner {\n        BONUS_REWARDS = multiplierNumber;\n    }\n\n    function setExchangeFeeRate(uint256 _exchangeFeeRate) external onlyOwner {\n        require(\n            _exchangeFeeRate < SafeDecimalMath.unit() / 10,\n            \"rate < MAX_EXCHANGE_FEE_RATE\"\n        );\n        exchangeFeeRate = _exchangeFeeRate;\n    }\n\n    function setFeePeriodDuration(uint256 _feePeriodDuration) public onlyOwner {\n        feePeriodDuration = _feePeriodDuration;\n        emit FeePeriodDurationUpdated(_feePeriodDuration);\n    }\n\n    function setTargetThreshold(uint256 _percent) public onlyOwner {\n        require(_percent >= 0, \"Threshold should be positive\");\n        require(_percent <= 50, \"Threshold too high\");\n        targetThreshold = _percent.mul(SafeDecimalMath.unit()).div(100);\n    }\n\n    function initFeePaid() public onlyOwner {\n        for (uint256 i = 0; i < FEE_PERIOD_LENGTH; i++) {\n            delete _recentFeePeriods[i];\n        }\n    }\n\n    function recordFeePaid(uint256 amount) external onlyExchangerOrSynth {\n        // Keep track off fees in xUSD in the open fee pool period.\n        _recentFeePeriodsStorage(0).feesToDistribute = _recentFeePeriodsStorage(\n            0\n        )\n            .feesToDistribute\n            .add(amount);\n    }\n\n    function recordRewardPaid(uint256 amount) external onlyExchangerOrSynth {\n        // Keep track off fees in xUSD in the open fee pool period.\n        _recentFeePeriodsStorage(0).rewardsToDistribute = _recentFeePeriodsStorage(\n            0\n        )\n            .rewardsToDistribute\n            .add(amount.mul(BONUS_REWARDS));\n    }\n\n    function recentFeePeriods(uint256 index)\n        external\n        view\n        returns (\n            uint64 feePeriodId,\n            uint64 startingDebtIndex,\n            uint64 startTime,\n            uint256 feesToDistribute,\n            uint256 feesClaimed,\n            uint256 rewardsToDistribute,\n            uint256 rewardsClaimed\n        )\n    {\n        FeePeriod memory feePeriod = _recentFeePeriodsStorage(index);\n        return (\n            feePeriod.feePeriodId,\n            feePeriod.startingDebtIndex,\n            feePeriod.startTime,\n            feePeriod.feesToDistribute,\n            feePeriod.feesClaimed,\n            feePeriod.rewardsToDistribute,\n            feePeriod.rewardsClaimed\n        );\n    }\n\n    /**\n     * @notice Close the current fee period and start a new one.\n     */\n    function closeCurrentFeePeriod() external {\n        require(\n            _recentFeePeriodsStorage(0).startTime <= (block.timestamp - feePeriodDuration),\n            \"Too early to close fee period\"\n        );\n\n        FeePeriod storage secondLastFeePeriod =\n            _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2);\n        FeePeriod storage lastFeePeriod =\n            _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 1);\n\n        // Any unclaimed fees from the last period in the array roll back one period.\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\n        // have already claimed from the old period, available in the new period.\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2)\n            .feesToDistribute = lastFeePeriod\n            .feesToDistribute\n            .sub(lastFeePeriod.feesClaimed)\n            .add(secondLastFeePeriod.feesToDistribute);\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2)\n            .rewardsToDistribute = lastFeePeriod\n            .rewardsToDistribute\n            .sub(lastFeePeriod.rewardsClaimed)\n            .add(secondLastFeePeriod.rewardsToDistribute);\n\n        // Shift the previous fee periods across to make room for the new one.\n        _currentFeePeriod = _currentFeePeriod.add(FEE_PERIOD_LENGTH).sub(1).mod(\n            FEE_PERIOD_LENGTH\n        );\n\n        // Clear the first element of the array to make sure we don't have any stale values.\n        delete _recentFeePeriods[_currentFeePeriod];\n\n        // Open up the new fee period.\n        // Increment periodId from the recent closed period feePeriodId\n        _recentFeePeriodsStorage(0).feePeriodId = uint64(\n            uint256(_recentFeePeriodsStorage(1).feePeriodId).add(1)\n        );\n        _recentFeePeriodsStorage(0).startingDebtIndex = uint64(\n            synthesizer().debtLedgerLength()\n        );\n        _recentFeePeriodsStorage(0).startTime = uint64(block.timestamp);\n\n        emit FeePeriodClosed(_recentFeePeriodsStorage(1).feePeriodId);\n    }\n\n    function claimFees() external returns (bool) {\n        return _claimFees(_msgSender());\n    }\n\n    function _claimFees(address claimingAddress) internal returns (bool) {\n        uint256 rewardsPaid = 0;\n        uint256 feesPaid = 0;\n        uint256 availableFees;\n        uint256 availableRewards;\n\n        // Address won't be able to claim fees if it is too far below the target c-ratio.\n        // It will need to burn synths then try claiming again.\n        require(\n            isFeesClaimable(claimingAddress),\n            \"C-Ratio below penalty threshold\"\n        );\n\n        (availableFees, availableRewards) = feesAvailable(claimingAddress);\n\n        require(\n            availableFees > 0 || availableRewards > 0,\n            \"No fees or rewards available for period, or fees already claimed\"\n        );\n\n        _setLastFeeWithdrawal(\n            claimingAddress,\n            _recentFeePeriodsStorage(1).feePeriodId\n        );\n\n        if (availableFees > 0) {\n            feesPaid = _recordFeePayment(availableFees);\n\n            _payFees(claimingAddress, feesPaid);\n        }\n\n        if (availableRewards > 0) {\n            rewardsPaid = _recordRewardPayment(availableRewards);\n\n            _payRewards(claimingAddress, rewardsPaid);\n        }\n\n        emit FeesClaimed(claimingAddress, feesPaid, rewardsPaid);\n\n        return true;\n    }\n\n    function isFeesClaimable(address account) public view returns (bool) {\n        // Threshold is calculated from ratio % above the target ratio (issuanceRatio).\n        //  0  <  10%:   Claimable\n        // 10% > above:  Unable to claim\n        uint256 ratio = synthesizer().collateralisationRatio(account);\n        uint256 targetRatio = synthesizer().issuanceRatio();\n\n        if (ratio < targetRatio) {\n            return true;\n        }\n\n        // Calculate the threshold for collateral ratio before fees can't be claimed.\n        uint256 ratio_threshold =\n            targetRatio.multiplyDecimal(\n                SafeDecimalMath.unit().add(targetThreshold)\n            );\n\n        // Not claimable if collateral ratio above threshold\n        if (ratio > ratio_threshold) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function feesAvailable(address account)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        // Add up the fees\n        uint256[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\n\n        uint256 totalFees = 0;\n        uint256 totalRewards = 0;\n\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\n        for (uint256 i = 1; i < FEE_PERIOD_LENGTH; i++) {\n            totalFees = totalFees.add(userFees[i][0]);\n            totalRewards = totalRewards.add(userFees[i][1]);\n        }\n\n        // And convert totalFees to xUSD\n        // Return totalRewards as is in DOWS amount\n        return (totalFees, totalRewards);\n    }\n\n    function feesByPeriod(address account)\n        public\n        view\n        returns (uint256[2][FEE_PERIOD_LENGTH] memory results)\n    {\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\n        uint256 userOwnershipPercentage;\n        uint256 debtEntryIndex;\n\n        (userOwnershipPercentage, debtEntryIndex) = _getAccountsDebtEntry(\n            account,\n            0\n        );\n\n        // If they don't have any debt ownership and they never minted, they don't have any fees.\n        // User ownership can reduce to 0 if user burns all synths,\n        // however they could have fees applicable for periods they had minted in before so we check debtEntryIndex.\n        if (debtEntryIndex == 0 && userOwnershipPercentage == 0) return results;\n\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\n        // fees owing for, so we need to report on it anyway.\n        uint256 feesFromPeriod;\n        uint256 rewardsFromPeriod;\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(\n            0,\n            userOwnershipPercentage,\n            debtEntryIndex\n        );\n\n        results[0][0] = feesFromPeriod;\n        results[0][1] = rewardsFromPeriod;\n\n        // Retrieve user's last fee claim by periodId\n        uint256 lastFeeWithdrawal = getLastFeeWithdrawal(account);\n\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\n        // Condition checks for periods > 0\n        for (uint256 i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\n            uint256 next = i - 1;\n            uint256 nextPeriodStartingDebtIndex =\n                _recentFeePeriodsStorage(next).startingDebtIndex;\n\n            // We can skip the period, as no debt minted during period (next period's startingDebtIndex is still 0)\n            if (\n                nextPeriodStartingDebtIndex > 0 &&\n                lastFeeWithdrawal < _recentFeePeriodsStorage(i).feePeriodId\n            ) {\n                // We calculate a feePeriod's closingDebtIndex by looking at the next feePeriod's startingDebtIndex\n                // we can use the most recent issuanceData[0] for the current feePeriod\n                // else find the applicableIssuanceData for the feePeriod based on the StartingDebtIndex of the period\n                uint256 closingDebtIndex =\n                    uint256(nextPeriodStartingDebtIndex).sub(1);\n\n                // Gas optimisation - to reuse debtEntryIndex if found new applicable one\n                // if applicable is 0,0 (none found) we keep most recent one from issuanceData[0]\n                // return if userOwnershipPercentage = 0)\n                (\n                    userOwnershipPercentage,\n                    debtEntryIndex\n                ) = _applicableIssuanceData(account, closingDebtIndex);\n\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(\n                    i,\n                    userOwnershipPercentage,\n                    debtEntryIndex\n                );\n\n                results[i][0] = feesFromPeriod;\n                results[i][1] = rewardsFromPeriod;\n            }\n        }\n        return results;\n    }\n\n    function getLastFeeWithdrawal(address _claimingAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return lastFeeWithdrawalStorage[_claimingAddress];\n    }\n\n    function _setLastFeeWithdrawal(\n        address _claimingAddress,\n        uint256 _feePeriodID\n    ) internal {\n        lastFeeWithdrawalStorage[_claimingAddress] = _feePeriodID;\n    }\n\n    function _getAccountsDebtEntry(address account, uint256 index)\n        internal\n        view\n        returns (uint256 debtPercentage, uint256 debtEntryIndex)\n    {\n        require(\n            index < FEE_PERIOD_LENGTH,\n            \"index exceeds the FEE_PERIOD_LENGTH\"\n        );\n\n        debtPercentage = accountIssuanceLedger[account][index].debtPercentage;\n        debtEntryIndex = accountIssuanceLedger[account][index].debtEntryIndex;\n    }\n\n    function _applicableIssuanceData(address account, uint256 closingDebtIndex)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        IssuanceData[FEE_PERIOD_LENGTH] memory issuanceData =\n            accountIssuanceLedger[account];\n\n        // We want to use the user's debtEntryIndex at when the period closed\n        // Find the oldest debtEntryIndex for the corresponding closingDebtIndex\n        for (uint256 i = 0; i < FEE_PERIOD_LENGTH; i++) {\n            if (closingDebtIndex >= issuanceData[i].debtEntryIndex) {\n                return (\n                    issuanceData[i].debtPercentage,\n                    issuanceData[i].debtEntryIndex\n                );\n            }\n        }\n    }\n\n    function _feesAndRewardsFromPeriod(\n        uint256 period,\n        uint256 ownershipPercentage,\n        uint256 debtEntryIndex\n    ) internal view returns (uint256, uint256) {\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\n        if (ownershipPercentage == 0) return (0, 0);\n\n        uint256 debtOwnershipForPeriod = ownershipPercentage;\n\n        // If period has closed we want to calculate debtPercentage for the period\n        if (period > 0) {\n            uint256 closingDebtIndex =\n                uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex)\n                    .sub(1);\n            debtOwnershipForPeriod = _effectiveDebtRatioForPeriod(\n                closingDebtIndex,\n                ownershipPercentage,\n                debtEntryIndex\n            );\n        }\n\n        // Calculate their percentage of the fees / rewards in this period\n        // This is a high precision integer.\n        uint256 feesFromPeriod =\n            _recentFeePeriodsStorage(period).feesToDistribute.multiplyDecimal(\n                debtOwnershipForPeriod\n            );\n\n        uint256 rewardsFromPeriod =\n            _recentFeePeriodsStorage(period)\n                .rewardsToDistribute\n                .multiplyDecimal(debtOwnershipForPeriod);\n\n        return (\n            feesFromPeriod.preciseDecimalToDecimal(),\n            rewardsFromPeriod.preciseDecimalToDecimal()\n        );\n    }\n\n    function _recentFeePeriodsStorage(uint256 index)\n        internal\n        view\n        returns (FeePeriod storage)\n    {\n        return\n            _recentFeePeriods[(_currentFeePeriod + index) % FEE_PERIOD_LENGTH];\n    }\n\n    function _effectiveDebtRatioForPeriod(\n        uint256 closingDebtIndex,\n        uint256 ownershipPercentage,\n        uint256 debtEntryIndex\n    ) internal view returns (uint256) {\n        // Figure out their global debt percentage delta at end of fee Period.\n        // This is a high precision integer.\n        uint256 feePeriodDebtOwnership =\n            synthesizer()\n                .debtLedger(closingDebtIndex)\n                .divideDecimalRoundPrecise(synthesizer().debtLedger(debtEntryIndex))\n                .multiplyDecimalRoundPrecise(ownershipPercentage);\n\n        return feePeriodDebtOwnership;\n    }\n\n    function _recordFeePayment(uint256 xUSDAmount) internal returns (uint256) {\n        // Don't assign to the parameter\n        uint256 remainingToAllocate = xUSDAmount;\n\n        uint256 feesPaid;\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint256 i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint256 feesAlreadyClaimed =\n                _recentFeePeriodsStorage(i).feesClaimed;\n            uint256 delta =\n                _recentFeePeriodsStorage(i).feesToDistribute.sub(\n                    feesAlreadyClaimed\n                );\n\n            if (delta > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint256 amountInPeriod =\n                    delta < remainingToAllocate ? delta : remainingToAllocate;\n\n                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed\n                    .add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                feesPaid = feesPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return feesPaid;\n\n                // We've exhausted feePeriods to distribute and no fees remain in last period\n                // User last to claim would in this scenario have their remainder slashed\n                if (i == 0 && remainingToAllocate > 0) {\n                    remainingToAllocate = 0;\n                }\n            }\n        }\n\n        return feesPaid;\n    }\n\n    function _payFees(address account, uint256 xUSDAmount)\n        internal\n        notFeeAddress(account)\n    {\n        // Checks not really possible but rather gaurds for the internal code.\n        require(\n            account != address(0) ||\n                account != address(this) ||\n                account != address(synthesizer()),\n            \"Can't send fees to this address\"\n        );\n\n        // Grab the xUSD Synth\n        Synth xUSDSynth = synthesizer().synths(xUSD);\n\n        // NOTE: we do not control the FEE_ADDRESS so it is not possible to do an\n        // ERC20.approve() transaction to allow this feePool to call ERC20.transferFrom\n        // to the accounts address\n\n        // Burn the source amount\n        xUSDSynth.burn(FEE_ADDRESS, xUSDAmount);\n\n        // Mint their new synths\n        xUSDSynth.issue(account, xUSDAmount);\n    }\n\n    function _recordRewardPayment(uint256 dowsAmount)\n        internal\n        returns (uint256)\n    {\n        // Don't assign to the parameter\n        uint256 remainingToAllocate = dowsAmount;\n\n        uint256 rewardPaid;\n\n        // Start at the oldest period and record the amount, moving to newer periods\n        // until we've exhausted the amount.\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\n        for (uint256 i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\n            uint256 toDistribute =\n                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(\n                    _recentFeePeriodsStorage(i).rewardsClaimed\n                );\n\n            if (toDistribute > 0) {\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\n                uint256 amountInPeriod =\n                    toDistribute < remainingToAllocate\n                        ? toDistribute\n                        : remainingToAllocate;\n\n                _recentFeePeriodsStorage(i)\n                    .rewardsClaimed = _recentFeePeriodsStorage(i)\n                    .rewardsClaimed\n                    .add(amountInPeriod);\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\n                rewardPaid = rewardPaid.add(amountInPeriod);\n\n                // No need to continue iterating if we've recorded the whole amount;\n                if (remainingToAllocate == 0) return rewardPaid;\n\n                // We've exhausted feePeriods to distribute and no rewards remain in last period\n                // User last to claim would in this scenario have their remainder slashed\n                // due to rounding up of PreciseDecimal\n                if (i == 0 && remainingToAllocate > 0) {\n                    remainingToAllocate = 0;\n                }\n            }\n        }\n        return rewardPaid;\n    }\n\n    function _payRewards(address account, uint256 dowsAmount)\n        internal\n        notFeeAddress(account)\n    {\n        require(account != address(0), \"Account can't be 0\");\n        require(account != address(this), \"Can't send rewards to fee pool\");\n        require(account != address(synthesizer()), \"Can't send rewards to shadows\");\n\n        // Record vesting entry for claiming address and amount\n        // DOWS already minted to rewardEscrow balance\n        rewardEscrow().appendVestingEntry(account, dowsAmount);\n    }\n\n    /**\n     * @dev onlyIssuer to call me on shadows.issue() & shadows.burn() calls to store the locked DOWS\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\n     */\n    function appendAccountIssuanceRecord(\n        address account,\n        uint256 debtRatio,\n        uint256 debtEntryIndex\n    ) external onlySynthesizer {\n        _appendAccountIssuanceRecord(\n            account,\n            debtRatio,\n            debtEntryIndex,\n            _recentFeePeriodsStorage(0).startingDebtIndex\n        );\n\n        emit IssuanceDebtRatioEntry(\n            account,\n            debtRatio,\n            debtEntryIndex,\n            _recentFeePeriodsStorage(0).startingDebtIndex\n        );\n    }\n\n    function _appendAccountIssuanceRecord(\n        address account,\n        uint256 debtRatio,\n        uint256 debtEntryIndex,\n        uint256 currentPeriodStartDebtIndex\n    ) private {\n        // Is the current debtEntryIndex within this fee period\n        if (\n            accountIssuanceLedger[account][0].debtEntryIndex <\n            currentPeriodStartDebtIndex\n        ) {\n            // If its older then shift the previous IssuanceData entries periods down to make room for the new one.\n            issuanceDataIndexOrder(account);\n        }\n\n        // Always store the latest IssuanceData entry at [0]\n        accountIssuanceLedger[account][0].debtPercentage = debtRatio;\n        accountIssuanceLedger[account][0].debtEntryIndex = debtEntryIndex;\n    }\n\n    function issuanceDataIndexOrder(address account) private {\n        for (uint256 i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\n            uint256 next = i + 1;\n            accountIssuanceLedger[account][next]\n                .debtPercentage = accountIssuanceLedger[account][i]\n                .debtPercentage;\n            accountIssuanceLedger[account][next]\n                .debtEntryIndex = accountIssuanceLedger[account][i]\n                .debtEntryIndex;\n        }\n    }\n\n    modifier onlyExchangerOrSynth {\n        bool isExchanger = msg.sender == address(exchanger());\n        bool isSynth = synthesizer().synthsByAddress(msg.sender) != bytes32(0);\n\n        require(isExchanger || isSynth, \"Only Exchanger, Synths Authorised\");\n        _;\n    }\n\n    function synthesizer() internal view returns (ISynthesizer) {\n        return\n            ISynthesizer(\n                resolver.requireAndGetAddress(\n                    \"Synthesizer\",\n                    \"Missing Synthesizer address\"\n                )\n            );\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return\n            IExchanger(\n                resolver.requireAndGetAddress(\n                    \"Exchanger\",\n                    \"Missing Exchanger address\"\n                )\n            );\n    }\n\n    function rewardEscrow() internal view returns (IRewardEscrow) {\n        return\n            IRewardEscrow(\n                resolver.requireAndGetAddress(\n                    \"RewardEscrow\",\n                    \"Missing RewardEscrow address\"\n                )\n            );\n    }\n\n    modifier onlySynthesizer {\n        require(\n            msg.sender == address(synthesizer()),\n            \"FeePool: Only Issuer Authorised\"\n        );\n        _;\n    }\n\n    modifier onlyExchanger {\n        require(\n            msg.sender == address(exchanger()),\n            \"FeePool: Only Exchanger Authorised\"\n        );\n        _;\n    }\n\n    modifier notFeeAddress(address account) {\n        require(account != FEE_ADDRESS, \"Fee address not allowed\");\n        _;\n    }\n\n    event FeePeriodDurationUpdated(uint256 newFeePeriodDuration);\n\n    event IssuanceDebtRatioEntry(\n        address account,\n        uint256 debtRatio,\n        uint256 debtEntryIndex,\n        uint256 feePeriodStartingDebtIndex\n    );\n\n    event FeePeriodClosed(uint256 feePeriodId);\n\n    event FeesClaimed(address account, uint256 xUSDAmount, uint256 dowsRewards);\n}\n"
    },
    "contracts/library/AddressResolverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./AddressResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract AddressResolverable is Ownable {\n    AddressResolver public resolver;\n\n    constructor(address _resolver)  {\n        resolver = AddressResolver(_resolver);\n    }\n\n    function setResolver(AddressResolver _resolver) public onlyOwner {\n        resolver = _resolver;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}